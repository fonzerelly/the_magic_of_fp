<!DOCTYPE html>
<html>
  <head>
    <title>The Magic of Functional Programming</title>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
    <style type="text/css">
      @import url(https://fonts.googleapis.com/css?family=Yanone+Kaffeesatz);
      @import url(https://fonts.googleapis.com/css?family=Droid+Serif:400,700,400italic);
      @import url(https://fonts.googleapis.com/css?family=Ubuntu+Mono:400,700,400italic);

      body { font-family: 'Droid Serif'; }
      h1, h2, h3 {
        font-family: 'Yanone Kaffeesatz';
        font-weight: normal;
      }
      li {
        font-family: 'Yanone Kaffeesatz';
        font-weight: normal;
        font-size: 2em;
      }
      .remark-code, .remark-inline-code { font-family: 'Ubuntu Mono'; font-size: 1.5em }
    </style>
  </head>
  <body>
    <textarea id="source">


class: center, middle

# The Magic of Functional Programming
## for DAB

---
class: center, middle
## How does Harry Potter let a book float?
<img src="images/harry_potter.jpg" width="60%">

- Steht er mit einer höheren Macht im Bunde?
- Ruft er die "float"-Methode des Buch-Objekts auf?
- Zieht er vielleicht alle Luftmoleküle unter dem Buch zusammen, so dass ein Luftkissen entsteht?

---
class: center, middle
##Nah - he is not that smart!
<img src="images/harry_potter_brain.jpg" width="60%">
<!-- &#45; Höhere Macht ist zwar Möglich, aber was wäre dan HP ohne diese Macht? Warum dreht sich  -->
<!--   dann in den Geschichten nicht alles um Gott oder den Teufel -->
<!-- &#45; Wenn es am Buch tatsächlich eine "float"&#45;Methode geben sollte, würde ich mir ernsthaft -->
<!--   um das Design der Realität sorgen machen. -->
<!-- &#45; Vielleicht, aber wie wählt er die Moleküle aus? -->
---
## Harry Potter's magic spell
* is not connected to the book directly
* can be combined with other spells
* is an interface to reduce the complexity of reality

<!-- Eines ist jedenfalls klar. Der Zauberspruch von Harry Potter muss folgende Anforderungen erfüllen: -->
<!-- &#45; Der Zauberspruch hat nix mit dem Buch zu tun. Man kann den Schwebespruch auf alle möglichen "Objekte" anwenden. -->
<!-- &#45; Man kann den Schwebespruch mit anderen Zaubersprüchen  kombinieren -->
<!-- &#45; Der Zauberspruch vereinfacht die Zugriff auf die Realität, in dem er zum einen -->
<!--    &#45; die richtigen Luftmoleküle auswählt -->
<!--    &#45; jedes einzelne Luftmolekühl in Aufwärtsbewegung versetzt. -->
<!--    &#45; Für beides dürfte ein anderer Magier sich schon mal einen Spruch ausgedacht haben, -->
<!--      so dass der Schwebespruch selbst wohl eine Kombination von Sprüchen enthält. -->
<!--  -->
<!-- Warum erzähl ich Euch überhaupt was über Harry Potter? Weil Programmieren meiner Meinung nach -->
<!-- viel mit Zauberrei zu tun hat. Und wie wir vielleicht noch sehen werden, gelten für Software -->
<!-- ähnliche Anforderungen wie für Zaubersprüche. Ich behaupte, dass wir mit Funktionaler Programierung -->
<!-- viel leichter diese Anforderungen erfüllen können... -->

---
class: center, middle
<img src="images/what_if_functional.jpg" width="80%">

<!-- Wenn Ihr schon mal JavaScript geschrieben habt, habt ihr mit großer Wahrscheinlichkeit schon mal -->
<!-- ansatzweise Funktional programmiert. Das kommt daher, dass xxx bei der Entwicklung von JavaScript -->
<!-- eher Scheme im Hinterkopf hatte als Java. Man hat JavaScript damals eigentlich nur aus Marketing&#45;Gründen -->
<!-- "Java" genannt und mit relativ schlechten Vererbungs&#45;Methoden versehen, weil eben Java damals der große -->
<!-- der "nhS" (neuester heißer Scheiß) war. -->
<!-- Was aber die wahre Macht von JavaScript ausmacht, sind Features die erst kürzlich Java8 hinzugefügt wurden. -->
<!-- Damit meine ich z.B. Lamdas und Closures -->
---
##Functions are "First-Class-Citizens"
```javascript
var clickHandler = function () {
  console.log("Click occured.");
};
$(document).on("click", clickhandler);
```
<!-- JavaScript&#45;Funktionen sind so genannte "First&#45;Class&#45;Citizens". D.h. sie können nach belieben  -->
<!-- &#45; Variablen zugeordnet werden,  -->
<!-- &#45; anderen Funktionen als Parameter über geben werden,  -->
<!-- &#45; ja sogar Rückgabewerte von anderen Funktionen sein. -->
---
##Closures
```javascript
var remember = function () {
  var value = 42;
  return function () {
    return value;
  };
};

var extract = remember();

extract(); //42
```
<!-- Der Function&#45;Scope von JavaScript erlaubt es nicht nur einer Funktion auf die Variablen der sie -->
<!-- umschließenden Funktion zu zugreifen, Die Variablen bleiben sogar erhalten, wenn die darauf ver&#45; -->
<!-- weisende Funktion als Rückgabewert den Function&#45;Scope verlässt. D.h. obwohl sogar die remember&#45; -->
<!-- funktion in diesem Beispiel ausgeführt wurde, bleibt der Wert der Variable value erhalten. Diesen -->
<!-- Speicherzustand nennt man Clousre. -->

---
##Higher Order Functions
```javascript
var myParams = [1,2,3],
    sliceParams = myParams
      .slice
      .bind(myParams, 1);

setTimeout(sliceParams, 1000);
//after one second myParams === [2,3]

```
<!-- Sog. Higher Order Functions wie setTimeout nehmen Funktionen als Parameter entgegen und/oder geben -->
<!-- Funktionen als Rückgabewert zurück. -->

---
class: center, middle
##... and I'll show you how deep the rabbit hole goes ...
<img src="images/the-matrix-red-or-blue-pill-o.gif", width="100%">

<!-- Durch diese Grundlagen ergeben sich ganz neue, ungeahnte Möglichkeiten zur Code&#45;Strukturierung.  -->
<!-- Ich für meinen Teil habe mir völlig neue Denkmuster über das Programmieren zugelegt und glaube -->
<!-- ein besserer Programmierer geworden zu sein, seit ich Funktional denke.  -->
<!-- Aber ich muss ehrlich sein, nicht nur das. Jedesmal wenn ich jetzt Java&#45;Code in die Hand nehmen  -->
<!-- muss kommt mir Java so unglaublich umständich vor. Alle Leute die ich kenne und sich mit Funktionaler -->
<!-- Programmierung angefreundet haben empfinden ebenso. Ich wette, es wird Euch ähnlich ergehen, wenn -->
<!-- ihr nach meinem Vortrag tiefer einsteigt. -->
---
class: center, middle
## Reduce Complexity
<img src="images/groundhog_day.gif" width="100%">
<!-- Für mich hat Funktionale Prorammierung angefangen, als ich noch mit C++ Navi&#45;Software geschrieben  -->
<!-- habe. Ständig habe ich furchtbar umständlichen Code geschrieben, der kaum wartbar war. Teilweise -->
<!-- sogar nach der Copy&#38;Paste&#45;Methode. -->
<!-- Selbst das schreiben von Schleifen war so umständlich, dass ich selbst nach mehreren Jahren immer  -->
<!-- wieder mal Tipfehler reingebaut habe, die ich nicht auf den ersten Blick erkennen konnte.  -->
<!-- Ich habe gelernt, wie wichtig es ist, jede Möglichkeit Komplexität im Code zu reduzieren.  -->
---
## What is the problem with this kind of loop?
```javascript
var nums = [1,2,3];
for(var i = 0; i &lt; nums.length; i++) {
  var num = nums[i];
  console.log(num);
}
```
<!-- Was ist z.B. bei dieser Schleife unnötig kompliziert? -->
<!--  -->
<!-- &#45; Wir müssen eine Zähler&#45;Variable pro Schleifendurchlauf mutieren -->
<!-- &#45; Beim Vergleich der Zähler&#45;Variable zur Array&#45;Länge können sich leicht Fehler einschleichen -->
<!-- &#45; Wir müssen nochmal extra das Element, welches uns interessiert, aus der Liste extrahieren -->

---
## JavaScript can do far better then that
```javascript
[1,2,3].forEach(function (num) {
  console.log(num);
});
```
* JS-Arrays come nativly with a forEach-Method
* Complexity gets reduced
* Shorter and clearer code

<!-- Die Arrays von JavaScript kommen mit mehreren Funktion höherer Ordnung, die das Iterieren -->
<!-- über Listen wesentlich vereinfachen. forEach z.B. erwartet eine Callback&#45;Funktion, die für jedes -->
<!-- Element in der Liste einmal aufgerufen wird. Die Zählervariable entfällt komplett. Stattdessen -->
<!-- bekomme ich das ListenElement automatisch in die Callback&#45;Funktion hineingereicht und kann damit -->
<!-- arbeiten. -->

---
class: middle, center
#Side Effects
<img src="/images/butterfly_effect.gif" width="90%">

<!-- Aber forEach hat ein Problem. Es eignet sich nur für das gewollte Ausführen von Seiten effekten. -->
<!-- Was ist ein Seiten&#45;Effekt? -->
<!--  -->
<!-- Ein Seiten&#45;Effekt ist die bewuste oder unbewuste manipulation des Gesamt&#45;Systems.  -->
<!-- console.log auszuführen ist z.B. ein Seiten&#45;Effekt. Denn es wird der State der globalen Console  -->
<!-- manipuliert und um einen String erweitert. -->
<!-- Seiten&#45;Effekte sind also wichtig. Sie erlauben die Interaktion mit der Software. Aber sie sind -->
<!-- stets State&#45;Behaftet so dass sich bei asynchroner Verarbeitung Probleme ergeben. In Sprachen wie -->
<!-- Java z.B. können mehrere Threads auf eine Variable zukreifen und ihren State manipulieren. Hierfür -->
<!-- muss umständlich der Zugriff auf eine Variable über Semaphoren und ähnliche Mechanismen serialisiert -->
<!-- werden. Schaut man sich aber der die Hardware&#45;Entwicklung der letzten Jahre an, so zeigt sich, dass -->
<!-- das Arbeiten mit mehreren Threads immer wichtiger wird, da die Prozessoren kaum noch Leistungsfähiger -->
<!-- werden dafür aber immer mehr Prozessorkerne in einem Computer verbaut werden. Um dieses Potential -->
<!-- auszuschöpfen sollte man darauf achten möglichst wenig Seiten&#45;Effekte in der Software zu verursachen. -->
<!-- Eine noch so komplexe Funktion kann zum Beispiel für jedes Element einer Liste gleichzeitig auf mehreren -->
<!-- Prozessoren ausgeführt werden, um dann die Ergebnisse aller Threads wieder zu einem Ausgabe&#45;Array -->
<!-- zusammen zu führen.  -->
---
## forEach is not appropriate for mutation
```javascript
[1,2,3].forEach(function (num) {
  return num * num;
}); // returns undefined
```
* forEach is appropriate for Side-Effect calls like console.log
* Usually you want to prevent SideEffects that might mutate globals...
* You can not manipulate the array in place

<!-- Davon mal abgesehen, vereinfacht sich das Schreiben von Software massiv, wenn man nicht ständig -->
<!-- darauf achten muss, in welchem Zustand eine Globale Variable gerade ist und sich eine Funktion -->
<!-- daran orientieren muss. Das Ziel ist es also stets neue, abgewandelte Versionen eines Arrays -->
<!-- erstellen, bis man das eigentliche Ergebnis ermittelt hat um sie dann für den Endnutzer auszugeben. -->
<!--  -->
<!-- Das wird mit forEach nicht funktionieren. Per Defaut liefert forEach nur undefined zurück. -->
---
## map lets you create a new version of the array
```javascript
[1,2,3].map(function (num) {
  return num * num;
}); // returns [1,4,9]
```
* map creates a new array corresponding to the return values of your mapping function
* keeping your original array as it was assures that other parts of your programm that depend on it still work as expected
---
## By the way...
```javascript
var square = function (x) {
  return x * x
};
[1,2,3].map(square);
```
* ... this is not only a new way to write loops
* You can also pass predefined mapping functions into .map or .forEach

---
class: center, middle
<img src="images/funny_or_not.jpg" width="90%">
---
## Predicate-Function
```javascript
var isFunny= function (joke) {
  return Boolean(joke.pointe);
};
```
* A so called predicate-function evaluates input data and returns
only a boolean value.
<!-- &#45; Eine Prädikats&#45;Funktion bewertet den Eingabe&#45;Parameter und liefert -->
<!--   einen boolean wert zurück, der die Annahme über den Eingabeparameter -->
<!--   bestätigt oder widerlegt -->
<!-- &#45; Prädikats&#45;Funktionen eignen sich zum Beispiel um eine Liste nach einer -->
<!--   Eigenschaft deren Elemente zu sortieren. -->
<!-- &#45; Genauso kann eine Prädikatis&#45;Funktion dazu dienen Elemente, die eine -->
<!--   bestimmte Eigenschaft nicht erfüllen zu filtern: -->
---
##Filter
```javascript
var jokes = [
  { type: "Chuck-Norris",
    text: "If a Chuck-Norris programm crashes,"
    pointe: "it is a feature!" },
  { type: "Math",
    text: "Black Holes are, where God devided"
    pointe: 1/0 }
};
jokes.filter(isFunny); // [{type:"Chuck-Norris",pointe: "..."}]
```
* You can use a so called predicate function that returns true or false to
  filter elements from a list.

<!-- &#45; Was haben nun die bisher gezeigten Schleifen&#45;Funktionen gemeinsam? -->
<!--     &#45;> Sie haben nur einen Parameter &#45; nämlich das Listenelement, das wir  -->
<!--        näher untersuchen wollen -->
<!-- &#45; Jetzt haben aber nicht alle Funktionen die wir schreiben nur einen Parameter -->
<!--     &#45;> Was tun, wenn ich sie nun doch direkt in so eine Schleifen&#45;Funktion übergeben will? -->
<!--  -->

---


    </textarea>

    <script src="scripts/remark-latest.min.js">
    </script>
    <script>
var slideshow = remark.create({
  highlightLanguage: 'javascript',
  highlightStyle: 'railscasts'
});
    </script>
  </body>
</html>
<!--  <mindmap> -->
<!--  *wenn ich eine funktion curry was erreiche ich damit -->
<!--  * ICH ERREICHE DASS EIN PARAMETER FESTGELEGT IST -->
<!--  +HEIsst daas zwangsläufig auch, dass die funktion pure ist? Nein: -->
<!--     selbst der festgetackerte parameter kann sich dynamishc ändern wenn er ein referenz objekt ist -->
<!--  * aber ich kann annahmen &uuml;ber die Änderung des Parameters treffen -->
<!--    dass er sich nicht ändert... dann muss ich ihn aber auch nicht zwingend -->
<!--    currien -->
<!-- * warum curry ich nen Parameter? -->
<!--   Weil ich die Funktion in einem Kontext verwenden will, in der ich ihr -->
<!--   diesen Parameter nicht zur Verf&uuml;gung stellen kann. -->
<!--  -->
<!--   get(member, obj) -->
<!--   map([objs],get("name")) -->
<!--   Was hat das nun mit dem unabhängig machen vom context zu tun? -->
<!--   &#45;> Ich kann von der Funktion via curry viele Varianten bilden, -->
<!--   die auf unterschiedliche Contexte passen. -->
<!--  -->
<!--  </mindmap> -->
<!-- *separate pure from impure &#45;> to take advantage of memoization -->

<!-- Verbesserungsvorschläge: -->
<!-- &#45; Reduce life vorf&uuml;hrung -->
<!-- &#45; Reduce beispiel mit Sum, Beispiel mit gr&ouml;ßer werdendem Array -->
<!--  -->
<!-- &#45; Partial application life Vorf&uuml;hrung -->
<!-- &#45; Klarstellen, dass es darauf ankommt, die Parameteranzahl auf 1 oder 0 zu bekommen, -->
<!--    so dass man die Funktionen mit map, und reduce gut verwenden kann. -->
<!--  -->
<!--    ?brauchen wir &uuml;berhaupt reduce? -->
<!--  -->
<!-- &#45; Live vorf&uuml;hrung memoize mit chatty add -->
<!--    !!! lodash wird auf der repl schnell undefined &#45; warum? !!! -->
<!--  -->
