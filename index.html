<!DOCTYPE html>
<html>
  <head>
    <title>The Magic of Functional Programming</title>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
    <style type="text/css">
      @import url(https://fonts.googleapis.com/css?family=Yanone+Kaffeesatz);
      @import url(https://fonts.googleapis.com/css?family=Droid+Serif:400,700,400italic);
      @import url(https://fonts.googleapis.com/css?family=Ubuntu+Mono:400,700,400italic);

      body { font-family: 'Droid Serif'; }
      h1, h2, h3 {
        font-family: 'Yanone Kaffeesatz';
        font-weight: normal;
      }
      li {
        font-family: 'Yanone Kaffeesatz';
        font-weight: normal;
        font-size: 2em;
      }
      .remark-code, .remark-inline-code { font-family: 'Ubuntu Mono'; font-size: 1.5em }
    </style>
  </head>
  <body>
    <textarea id="source">


class: center, middle

# The Magic of Functional Programming
## for DAB

---
class: center, middle
## How does Harry Potter let a book float?
<img src="images/harry_potter.jpg" width="60%">

- Steht er mit einer höheren Macht im Bunde?
- Ruft er die "float"-Methode des Buch-Objekts auf?
- Zieht er vielleicht alle Luftmoleküle unter dem Buch zusammen, so dass ein Luftkissen entsteht?

---
class: center, middle
##Nah - he is not that smart!
<img src="images/harry_potter_brain.jpg" width="60%">
<!-- &#45; Höhere Macht ist zwar Möglich, aber was wäre dan HP ohne diese Macht? Warum dreht sich  -->
<!--   dann in den Geschichten nicht alles um Gott oder den Teufel -->
<!-- &#45; Wenn es am Buch tatsächlich eine "float"&#45;Methode geben sollte, würde ich mir ernsthaft -->
<!--   um das Design der Realität sorgen machen. -->
<!-- &#45; Vielleicht, aber wie wählt er die Moleküle aus? -->
---
## Harry Potter's magic spell
* is not connected to the book directly
* can be combined with other spells
* is an interface to reduce the complexity of reality

<!-- Eines ist jedenfalls klar. Der Zauberspruch von Harry Potter muss folgende Anforderungen erfüllen: -->
<!-- &#45; Der Zauberspruch hat nix mit dem Buch zu tun. Man kann den Schwebespruch auf alle möglichen "Objekte" anwenden. -->
<!-- &#45; Man kann den Schwebespruch mit anderen Zaubersprüchen  kombinieren -->
<!-- &#45; Der Zauberspruch vereinfacht die Zugriff auf die Realität, in dem er zum einen -->
<!--    &#45; die richtigen Luftmoleküle auswählt -->
<!--    &#45; jedes einzelne Luftmolekühl in Aufwärtsbewegung versetzt. -->
<!--    &#45; Für beides dürfte ein anderer Magier sich schon mal einen Spruch ausgedacht haben, -->
<!--      so dass der Schwebespruch selbst wohl eine Kombination von Sprüchen enthält. -->
<!--  -->
<!-- Warum erzähl ich Euch überhaupt was über Harry Potter? Weil Programmieren meiner Meinung nach -->
<!-- viel mit Zauberrei zu tun hat. Und wie wir vielleicht noch sehen werden, gelten für Software -->
<!-- ähnliche Anforderungen wie für Zaubersprüche. Ich behaupte, dass wir mit Funktionaler Programierung -->
<!-- viel leichter diese Anforderungen erfüllen können... -->

---
class: center, middle
<img src="images/what_if_functional.jpg" width="80%">

<!-- Wenn Ihr schon mal JavaScript geschrieben habt, habt ihr mit großer Wahrscheinlichkeit schon mal -->
<!-- ansatzweise Funktional programmiert. Das kommt daher, dass Brendan Eich bei der Entwicklung von JavaScript -->
<!-- eher Scheme im Hinterkopf hatte als Java. Man hat JavaScript damals eigentlich nur aus Marketing&#45;Gründen -->
<!-- "Java" genannt und mit relativ schlechten Vererbungs&#45;Methoden versehen, weil eben Java damals der große -->
<!-- der "nhS" (neuester heißer Scheiß) war. -->
<!-- Was aber die wahre Macht von JavaScript ausmacht, sind Features die erst kürzlich Java8 hinzugefügt wurden. -->
<!-- Damit meine ich z.B. Lamdas und Closures -->
---
##Functions are "First-Class-Citizens"
```javascript
var clickHandler = function () {
  console.log("Click occured.");
};
$(document).on("click", clickhandler);
```
<!-- JavaScript&#45;Funktionen sind so genannte "First&#45;Class&#45;Citizens". D.h. sie können nach belieben  -->
<!-- &#45; Variablen zugeordnet werden,  -->
<!-- &#45; anderen Funktionen als Parameter über geben werden,  -->
<!-- &#45; ja sogar Rückgabewerte von anderen Funktionen sein. -->
---
##Closures
```javascript
var remember = function () {
  var value = 42;
  return function () {
    return value;
  };
};

var extract = remember();

extract(); //42
```
<!-- Der Function&#45;Scope von JavaScript erlaubt es nicht nur einer Funktion auf die Variablen der sie -->
<!-- umschließenden Funktion zu zugreifen, Die Variablen bleiben sogar erhalten, wenn die darauf ver&#45; -->
<!-- weisende Funktion als Rückgabewert den Function&#45;Scope verlässt. D.h. obwohl sogar die remember&#45; -->
<!-- funktion in diesem Beispiel ausgeführt wurde, bleibt der Wert der Variable value erhalten. Diesen -->
<!-- Speicherzustand nennt man Clousre. -->

---
##Higher Order Functions
```javascript
var myParams = [1,2,3],
    sliceParams = myParams
      .slice
      .bind(myParams, 1);

setTimeout(sliceParams, 1000);
//after one second myParams === [2,3]

```
<!-- Sog. Higher Order Functions wie setTimeout nehmen Funktionen als Parameter entgegen und/oder geben -->
<!-- Funktionen als Rückgabewert zurück. -->

---
class: center, middle
##... and I'll show you how deep the rabbit hole goes ...
<img src="images/the-matrix-red-or-blue-pill-o.gif", width="100%">

<!-- Durch diese Grundlagen ergeben sich ganz neue, ungeahnte Möglichkeiten zur Code&#45;Strukturierung.  -->
<!-- Ich für meinen Teil habe mir völlig neue Denkmuster über das Programmieren zugelegt und glaube -->
<!-- ein besserer Programmierer geworden zu sein, seit ich Funktional denke.  -->
<!-- Aber ich muss ehrlich sein, nicht nur das. Jedesmal wenn ich jetzt Java&#45;Code in die Hand nehmen  -->
<!-- muss kommt mir Java so unglaublich umständich vor. Alle Leute die ich kenne und sich mit Funktionaler -->
<!-- Programmierung angefreundet haben empfinden ebenso. Ich wette, es wird Euch ähnlich ergehen, wenn -->
<!-- ihr nach meinem Vortrag tiefer einsteigt. -->
---
class: center, middle
## Reduce Complexity
<img src="images/groundhog_day.gif" width="100%">
<!-- Für mich hat Funktionale Prorammierung angefangen, als ich noch mit C++ Navi&#45;Software geschrieben  -->
<!-- habe. Ständig habe ich furchtbar umständlichen Code geschrieben, der kaum wartbar war. Teilweise -->
<!-- sogar nach der Copy&#38;Paste&#45;Methode. -->
<!-- Selbst das schreiben von Schleifen war so umständlich, dass ich selbst nach mehreren Jahren immer  -->
<!-- wieder mal Tipfehler reingebaut habe, die ich nicht auf den ersten Blick erkennen konnte.  -->
<!-- Ich habe gelernt, wie wichtig es ist, jede Möglichkeit Komplexität im Code zu reduzieren.  -->
---
## What is the problem with this kind of loop?
```javascript
var nums = [1,2,3];
for(var i = 0; i &lt; nums.length; i++) {
  var num = nums[i];
  console.log(num);
}
```
<!-- Was ist z.B. bei dieser Schleife unnötig kompliziert? -->
<!--  -->
<!-- &#45; Wir müssen eine Zähler&#45;Variable pro Schleifendurchlauf mutieren -->
<!-- &#45; Beim Vergleich der Zähler&#45;Variable zur Array&#45;Länge können sich leicht Fehler einschleichen -->
<!-- &#45; Wir müssen nochmal extra das Element, welches uns interessiert, aus der Liste extrahieren -->

---
## JavaScript can do far better then that
```javascript
[1,2,3].forEach(function (num) {
  console.log(num);
});
```
* JS-Arrays come nativly with a forEach-Method
* Complexity gets reduced
* Shorter and clearer code

<!-- Die Arrays von JavaScript kommen mit mehreren Funktion höherer Ordnung, die das Iterieren -->
<!-- über Listen wesentlich vereinfachen. forEach z.B. erwartet eine Callback&#45;Funktion, die für jedes -->
<!-- Element in der Liste einmal aufgerufen wird. Die Zählervariable entfällt komplett. Stattdessen -->
<!-- bekomme ich das ListenElement automatisch in die Callback&#45;Funktion hineingereicht und kann damit -->
<!-- arbeiten. Dieser Code ist weniger komplex, leichter zu Verstehen und elegant. -->

---
class: middle, center
#Side Effects
<img src="/images/butterfly_effect.gif" width="90%">

<!-- Aber forEach hat ein Problem. Es eignet sich nur für das gewollte Ausführen von Seiten effekten. -->
<!-- Was ist ein Seiten&#45;Effekt? -->
<!--  -->
<!-- Ein Seiten&#45;Effekt ist die bewuste oder unbewuste manipulation des Gesamt&#45;Systems.  -->
<!-- console.log auszuführen ist z.B. ein Seiten&#45;Effekt. Denn es wird der State der globalen Console  -->
<!-- manipuliert und um einen String erweitert. -->
<!-- Seiten&#45;Effekte sind also wichtig. Sie erlauben die Interaktion mit der Software. Aber sie sind -->
<!-- stets State&#45;Behaftet so dass sich bei asynchroner Verarbeitung Probleme ergeben. In Sprachen wie -->
<!-- Java z.B. können mehrere Threads auf eine Variable zukreifen und ihren State manipulieren. Hierfür -->
<!-- muss umständlich der Zugriff auf eine Variable über Semaphoren und ähnliche Mechanismen serialisiert -->
<!-- werden. Schaut man sich aber der die Hardware&#45;Entwicklung der letzten Jahre an, so zeigt sich, dass -->
<!-- das Arbeiten mit mehreren Threads immer wichtiger wird, da die Prozessoren kaum noch Leistungsfähiger -->
<!-- werden dafür aber immer mehr Prozessorkerne in einem Computer verbaut werden. Um dieses Potential -->
<!-- auszuschöpfen sollte man darauf achten möglichst wenig Seiten&#45;Effekte in der Software zu verursachen. -->
<!-- Eine noch so komplexe Funktion kann zum Beispiel für jedes Element einer Liste gleichzeitig auf mehreren -->
<!-- Prozessoren ausgeführt werden, um dann die Ergebnisse aller Threads wieder zu einem Ausgabe&#45;Array -->
<!-- zusammen zu führen.  -->
---
## forEach is not appropriate for mutation
```javascript
[1,2,3].forEach(function (num) {
  return num * num;
}); // returns undefined
```
* forEach is appropriate for Side-Effect calls like console.log
* Usually you want to prevent SideEffects that might mutate globals...
* You can not manipulate the array in place

<!-- Davon mal abgesehen, vereinfacht sich das Schreiben von Software massiv, wenn man nicht ständig -->
<!-- darauf achten muss, in welchem Zustand eine Globale Variable gerade ist und sich eine Funktion -->
<!-- daran orientieren muss. Das Ziel ist es also stets neue, abgewandelte Versionen eines Arrays -->
<!-- erstellen, bis man das eigentliche Ergebnis ermittelt hat um sie dann für den Endnutzer auszugeben. -->
<!--  -->
<!-- Das wird mit forEach nicht funktionieren. Per Defaut liefert forEach nur undefined zurück. -->
---
## map lets you create a new version of an array
```javascript
[1,2,3].map(function (num) {
  return num * num;
}); // returns [1,4,9]
```
* map creates a new array corresponding to the return values of your mapping function
* keeping your original array as it was assures that other parts of your programm that depend on it still work as expected

<!-- .map speichert das Ergebnis der Callback&#45;Funktion in einem neuen Array, so dass wie in diesem -->
<!-- Beispiel, seiteneffekt&#45;frei die Quadrate einer Liste ermittelt werden können. .map ist vermutlich -->
<!-- eine der wichtigsten Funktionen in der funktionalen Denke. -->
---
## By the way...
```javascript
var square = function (x) {
  return x * x
};
[1,2,3].map(square);
```
* ... this is not only a new way to write loops
* You can also pass predefined mapping functions into .map or .forEach

<!-- Dabei sei erwähnt, dass die Schreibweise mit der Funktion nicht einfach nur eine Durchgeknallte -->
<!-- Methode ist eine Schleife zu schreiben. Was wir bisher gemacht haben, war dass wir stets eine  -->
<!-- anonyme Funktion als Callback definiert haben. Das muss aber nicht so sein. Wir können ebenso gut -->
<!-- benannte Funktionen übergeben, die wir auch an anderer Stelle wieder verwenden könnten. Dafür gibt -->
<!-- es noch weitere Beispiele. -->
<!--  -->
---
class: center, middle
<img src="images/funny_or_not.jpg" width="90%">
<!-- Jean&#45;Luc hier hat das Problem, dass er zwischen lustigen und unlustigen Witzen unterscheiden soll. -->
<!-- Wenn wir nun eine Funktion schreiben, die ihm das erlaubt, wie sieht ihr Interface aus und wo -->
<!-- könnte man die Funktion noch einsetzen. -->
---
## Predicate-Function
```javascript
var isFunny= function (joke) {
  return Boolean(joke.pointe);
};
```
* A so called predicate-function evaluates input data and returns
only a boolean value.
<!-- &#45; Eine Prädikats&#45;Funktion bewertet den Eingabe&#45;Parameter und liefert -->
<!--   einen boolean wert zurück, der die Annahme über den Eingabeparameter -->
<!--   bestätigt oder widerlegt -->
<!-- &#45; Prädikats&#45;Funktionen eignen sich zum Beispiel um eine Liste nach einer -->
<!--   Eigenschaft deren Elemente zu sortieren. -->
<!-- &#45; Genauso kann eine Prädikatis&#45;Funktion dazu dienen Elemente, die eine -->
<!--   bestimmte Eigenschaft nicht erfüllen zu filtern: -->
---
##Filter
```javascript
var jokes = [
  { type: "Chuck-Norris",
    text: "If a Chuck-Norris programm crashes,"
    pointe: "it is a feature!" },
  { type: "Math",
    text: "Black Holes are, where God devided"
    pointe: 1/0 }
};
jokes.filter(isFunny);
// [{type:"Chuck-Norris",text: "..."}]
```
* You can use a so called predicate function that returns true or false to
  filter elements from a list.

<!-- Ähnlich wie .map liefert.filter ein neues Array, in dem jedoch all die Listen&#45;Elemente fehlen, -->
<!-- für die die Prädikats&#45;Funktion false zurück geliefert hat. So kommt es, dass in diesem -->
<!-- Beispiel nur der Chuck&#45;Norris&#45;Witz übrig bleibt, da die pointe des Mathe&#45;Witzes "undefined" ergibt -->

---
class: center, middle
## Spice up your functions
<img src="images/currying.png" width = "50%">

<!-- &#45; Was haben nun die bisher gezeigten Schleifen&#45;Funktionen gemeinsam? -->
<!--     &#45;> Sie haben nur einen Parameter &#45; nämlich das Listenelement, das wir  -->
<!--        näher untersuchen wollen -->
<!-- &#45; Jetzt haben aber nicht alle Funktionen die wir schreiben nur einen Parameter -->
<!-- Die Eigenschaft einer Funktion, die angibt wie viele Parameter diese benötigt um ein valides -->
<!-- Ergebnis zu liefern nennen wir: Arity -->


---
## Arity
```javascript
var add = function (a, b) {
  return a + b;
};
```
* Arity is the property of a function, that describes how many parameters are needed.
* In this example the function "add" has the arity of 2.

<!-- Die Funktion 'add' hier hat eine Arity von 2, da sie die beiden -->
<!-- Parameter a und b benötigt. Möchte ich nun die add&#45;Funktion z.B. in einer .map&#45;Anweisung verwenden, -->
<!-- dann hab ich ein Problem. Denn .map liefert mir immer nur einen Parameter der Liste.  -->
<!--     &#45;> Was tun, wenn ich sie nun doch direkt in so eine Schleifen&#45;Funktion übergeben will? -->

---
##Embedding in a Function
```javascript
var inc2 = function(b) {
  return add(2, b);
};
inc2(3) //5

[1,2,3].map(inc2); //[3,4,5]
```
<!-- Wenn wir add nicht neu schreiben wollen, (weil die funktion ja so komplex ist ;) dann können wir -->
<!-- add von einer neuen Funktion aus aufrufen. -->
<!-- In diesem Beispiel hier packen wir add in ein Closure,  und legen für a den Wert 2 fest, so dass die neue Funktion inc2 jedweden  -->
<!-- Parameter um 2 erhöt. inc2 benötigt nun nur noch den Parameter und kann Problemlos in .map übergeben  -->
<!-- werden. -->
---
##Binding a Function
```javascript
var inc2 = add.bind(null, 2)
inc2(3) //5

[1,2,3].map(inc2); //[3,4,5]
```
<!-- Diese Schreibarbeit lässt sich durch das "binden" einer Funktion verkürzen. Jedes Function&#45;Object -->
<!-- in JavaScript verfügt über eine.bind&#45;Methode. Vermutlich kennt ihr diese Methode eher von der -->
<!-- Problemstellung, dass ihr eine Methode eines Objekts an setTimeout übergeben wollt und das -->
<!-- "this"&#45;Binding bewahren wollt. -->
<!-- Hier wird quasi eine neue Funktion erstellt, deren this.binding festgelegt ist und nicht mehr -->
<!-- verändert werden kann. Weil unsere add&#45;Methode keinerlei this&#45;Aufrufe beinhaltet können wir -->
<!-- ruhigen Gewissens null als ersten Parameter vergeben. Alle weiteren Parameter werden aber -->
<!-- den Eingabeparametern von add zu geordnet beginnend mit dem ersten Parameter von links. -->
<!-- D.h. auch hier weisen wir dem Parameter a von add den Wert 2 zu. -->

---
class: middle, center
<img src="images/curry.png" width="40%">

<!-- Aber es gibt noch eine viel flexiblere Methode, die wir  dem Mathematiker Haskell Curry zu  -->
<!-- verdanken haben. Er lieh seinem Namen nicht nur dem heute gebräuchlichen Wort "currying" -->
<!-- was also gar nichts mehr mit Würzen zu tun hat, sondern oben drein auch der Programmiersprache  -->
<!-- Haskell, die deren Entwickler ihm zu ehren postum so benannt haben.  -->
---
class: center, middle
##Currying
* The Basic idea behind currying is to take a function with n arguments and create from it n functions
  with one argument each:

###f(x, y, z) = g(x)(y)(z)
<!-- Die Idee hinter dem Curring ist folgende: Ich kann aus einer Funktion die n Parameter braucht, -->
<!-- n Funktionen bauen die jeweils nur einen Parameter brauchen. Haskell Curry beschäftigte sich mit  -->
<!-- dieser Idee, weil er ähnlich wie wir das Problem hatte, seine Funktionen zu vereinfachen zu müssen  -->
<!-- um einen mathematischen Beweis einfacher erbringen zu können. -->
<!-- Wie wir gleich sehen werden, ist diese Idee jedoch nicht praxisfern wie der Mathematik im -->
<!-- allgemeinen unterstellt wird, sondern das Currying erlaubt uns die Arity einer Funktion noch viel -->
<!-- flexibler zu manipulieren als die bisherigen Methoden. -->
---
##_.curry
```javascript
var add = _.curry(function(a, b) {
  return a + b;
});
add(2)    //returns a function with the arity 1
add(2)(3) //arity of add fullfilled: evaluates 5

var inc2 = add(2);

_.map([1,2,3], inc2);   //[3,4,5]
//but also:
_.map([1,2,3], add(3)); //[4,5,6]
```
<!-- Bisher haben wir uns auf die  Bordmittel von JavaScript beschränkt. Diese hingen aber imemr -->
<!-- an bestimmten JavaScript&#45;Objekten dran und werden teilweise nicht von allen JS&#45;Umebungen  -->
<!-- unterstützt. .bind z.B. gibt es unter PhantomJS nicht. -->
<!-- Statt dessen greifen wir nun auf Lodash zurück. Diese Library, stellt uns ebenso alle bisher  -->
<!-- behandelten Funktionen wie .map, .filter und .bind bereit. Aber noch ein Menge mehr. -->
<!-- Dazu zählt auch _.curry, mit der ich eben eine Funktion wie add mit zwei Parametern in zwei -->
<!-- Funktionen uwandeln kann.  -->
<!--  -->
<!-- Was heißt das genau? Im Obigen Beispiel haben wir also add gecurried. -->
<!-- Wenn ich nun add mit einem Parameter aufrufe bekomme ich nicht NaN zurück, sondern eine -->
<!-- Funktion der Arity 1. Rufe ich diese wieder mit dem Parameter 3 auf, ist die Arity von add erfüllt -->
<!-- so dass add ausgeführt werden kann und sich die Summe aus 2 und 3 ergibt. Wir können also  -->
<!-- ähnlich wie zuvor unsere inc2 Funktion erstellen, indem wir schlicht add mit dem Parameter 2 -->
<!-- aufrufen. Aber nun können wir mit leichtigkeit verschiedenste Varianten von add bilden. So z.B. -->
<!-- add(3) und dessen ergebnis einer _.map&#45;Funktion übergeben. -->
<!--  -->





    </textarea>

    <script src="scripts/remark-latest.min.js">
    </script>
    <script>
var slideshow = remark.create({
  highlightLanguage: 'javascript',
  highlightStyle: 'railscasts'
});
    </script>
  </body>
</html>
<!--  <mindmap> -->
<!--  *wenn ich eine funktion curry was erreiche ich damit -->
<!--  * ICH ERREICHE DASS EIN PARAMETER FESTGELEGT IST -->
<!--  +HEIsst daas zwangsläufig auch, dass die funktion pure ist? Nein: -->
<!--     selbst der festgetackerte parameter kann sich dynamishc ändern wenn er ein referenz objekt ist -->
<!--  * aber ich kann annahmen &uuml;ber die Änderung des Parameters treffen -->
<!--    dass er sich nicht ändert... dann muss ich ihn aber auch nicht zwingend -->
<!--    currien -->
<!-- * warum curry ich nen Parameter? -->
<!--   Weil ich die Funktion in einem Kontext verwenden will, in der ich ihr -->
<!--   diesen Parameter nicht zur Verf&uuml;gung stellen kann. -->
<!--  -->
<!--   get(member, obj) -->
<!--   map([objs],get("name")) -->
<!--   Was hat das nun mit dem unabhängig machen vom context zu tun? -->
<!--   &#45;> Ich kann von der Funktion via curry viele Varianten bilden, -->
<!--   die auf unterschiedliche Contexte passen. -->
<!--  -->
<!--  </mindmap> -->
<!-- *separate pure from impure &#45;> to take advantage of memoization -->

<!-- Verbesserungsvorschläge: -->
<!-- &#45; Reduce life vorf&uuml;hrung -->
<!-- &#45; Reduce beispiel mit Sum, Beispiel mit gr&ouml;ßer werdendem Array -->
<!--  -->
<!-- &#45; Partial application life Vorf&uuml;hrung -->
<!-- &#45; Klarstellen, dass es darauf ankommt, die Parameteranzahl auf 1 oder 0 zu bekommen, -->
<!--    so dass man die Funktionen mit map, und reduce gut verwenden kann. -->
<!--  -->
<!--    ?brauchen wir &uuml;berhaupt reduce? -->
<!--  -->
<!-- &#45; Live vorf&uuml;hrung memoize mit chatty add -->
<!--    !!! lodash wird auf der repl schnell undefined &#45; warum? !!! -->
<!--  -->
